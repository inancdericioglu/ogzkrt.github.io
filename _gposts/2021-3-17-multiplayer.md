---
layout: post
title: Multiplayer Game with Java LibGDX and Kryonet
---

This posts explains how to develop Multiplayer game with Java by using LibGDX and Kryonet. If you able bear until the end of this post and follow all the steps, your final product will be something like this:


<p align="center">
<img src="/images/multiplayer/killthemall.gif" alt="Game Play GIF" width="1000">
</p>

The game that we are going to develop will be Desktop Game and you will able to run it on Windows Linux MacOS.

### Note

Each section of this post has also have tutorial video on youtube. If you like this post please Subscribe to my channel.

## Table of Contents

* [Setup Installation](#installation)
* [Project Layout](#project-layout)
* [Utility Classes](#utility-classes)
* [Authorative Server Approach](#authorative-server-approach)
* [State Structure](#state-mechanism)
* [Play State](#play-state)
* [Menu State](#menu-state)
* [Game Over State](#architecture)
* [Font Rendering](#font-rendering)
* [Basic Connection with Server](#basic-connection-with-server)
* [Creating Player](#creating-player)
* [Input Processing](#input-processing)
* [Server-side Enemy Generation](#server-side-enemy-generation)
* [Sending Inputs to the Server](#sending-inputs-to-the-server)
* [Rendering Other Players](#rendering-other-players)
* [Shooting](#shooting)
* [Collision Detection](#collision-detection)
* [Conclusion](#conclusion)


## Installation

We will be using LibGDX framework. LibGDX is a cross-platform open source Java game development framework.
You should download **gdx-setup_latest.jar** from libGDX official [website](https://libgdx.com/dev/project-generation/). Then run that jar file, after running you supposed to see GUI called LibGDX Project Generator.

<p align="center">
<img src="/images/multiplayer/setup.jpg" alt="LibGDX Project Generator" width="500">
</p>
Fill the following fields.
- Name 
- Package
- Destination

As you can see, project generator ask us about the **Android SDK** location because LibGDX will also generate android project for us. Since our game will support only Desktop, uncheck the checkboxes other than **Desktop** in Sub Projects section.


Also make sure you checked the Freetype which will be used to draw fonts, from the extensions section in Project Generator.

After filling necessary fields push the generate button and wait few seconds. You should be seeing **BUILD SUCCESSFUL** log.

<p align="center">
<img src="/images/multiplayer/generated.png" alt="LibGDX Project Generator" width="500">
</p>

Now, we can import the project generated by setup app to our IDE. I will be using Eclipse during these tutorials (because I'm comfortable with it) but you can use whatever IDE you want as long as it supports **Gradle Projects**.

Do the following steps for importing project to the Eclipse

- From **File** menu, Choose the **Import** menuitem.
- From the dialog Choose **Gradle** -> **Existing Gradle Project** (If you don't have Gradle section in this dialog, install Gradle Plugin from MarketPlace
- Browse the folder that you have generated with setup app and press the **Finish** button.

Now, you should have three different project in your project explorer on the left if you are also using Eclipse like me. From Desktop project, choose the DesktopLauncher.java and run it. If you see a window pop out on your screen like this, it means you are good to go.

<p align="center">
<img src="/images/multiplayer/after_inst.png" alt="Game Window" width="1000">
</p>

If you prefer to watch or having problem during the installation, you can also watch the [tutorial]() video that I made. 

## Project Layout

Project that we have generated with setup app has folder structure like this. Projects root folder has three sub folders which are:
- core (this is the folder where we are going to write our code)
- desktop (this folder has Desktop project)
- gradle 

``` bash
├── core
│   ├── assets
│   └── src
│       └── com
│           └── javakaian
│               └── game
├── desktop
│   └── src
│       └── com
│           └── javakaian
│               └── game
│                   └── desktop
└── gradle
    └── wrapper
```

Instead of core and desktop folders, I want **Client** and **Server** folders inside the root directory.
- Cliend (Our client code will be here)
- Server (Our server side code will be here).





Do the following things to step by step.

- Inside the build.gradle file remove the project **core** and **desktop** and paste the following projects instead of them.
```gradle
project(":client") {
    apply plugin: "java-library"


    dependencies {
    	api "com.badlogicgames.gdx:gdx-backend-lwjgl:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx-box2d-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx-freetype-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        compile "com.esotericsoftware:kryonet:2.22.0-RC1"
        
    }
}
project(":server") {
    apply plugin: "java-library"


    dependencies {
     	api "com.badlogicgames.gdx:gdx-backend-lwjgl:$gdxVersion"
     	api "com.badlogicgames.gdx:gdx-backend-headless:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-platform:$gdxVersion:natives-desktop"
        api "com.badlogicgames.gdx:gdx:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-box2d:$gdxVersion"
        api "com.badlogicgames.gdx:gdx-freetype:$gdxVersion"
        compile "com.esotericsoftware:kryonet:2.22.0-RC1"
        
    }
}
```
- Delete the desktop folder
- Rename the **core** folder to the **client**
- Copy **client** folder and rename it as **server**
- Open the **settings.gradle** replace its content with 
```bash
include 'client','server'
```
- Browse the **build.gradle** file inside the **client**  folder and replace it's content with this.
```bash
sourceCompatibility = 1.8
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
sourceSets.main.java.srcDirs = [ "src/" ]
project.ext.assetDir = new File("./assets")
sourceSets.main.resources.srcDirs = ["./assets"]
eclipse.project.name = appName + "-client"
```

- Browse the **build.gradle** file inside the **server**  folder and it's replace content with this.
```bash
sourceCompatibility = 1.8
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'
sourceSets.main.java.srcDirs = [ "src/" ]
eclipse.project.name = appName + "-server"
```

- Inside the **Killthemall-server** project rename the **Killthemall.java** to **KillthemallServer.java** and replace its content with this.

```java

package com.javakaian.game;
import com.badlogic.gdx.ApplicationAdapter;

public class KillthemallServer extends ApplicationAdapter {

	@Override
	public void create() {
		System.out.println("Server created..");
	}

	@Override
	public void render() {
	}

}

```

- Create a main class for server. Since our server does not need GUI, we will be using HeadlessApplication.

```java

package com.javakaian.game;

import com.badlogic.gdx.backends.headless.HeadlessApplication;
import com.badlogic.gdx.backends.headless.HeadlessApplicationConfiguration;

public class ServerMain {

	public static void main(String[] args) {

		HeadlessApplicationConfiguration conf = new HeadlessApplicationConfiguration();
		conf.updatesPerSecond = 60;

		new HeadlessApplication(new KillthemallServer(), conf);
	}

}
```
Now we will do the same things for client.
- Inside the **Killthemall-client** project rename the **Killthemall.java** to **KillthemallClient.java** and replace its content with this.

```java
package com.javakaian.game;

import com.badlogic.gdx.ApplicationAdapter;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.utils.ScreenUtils;

public class KillthemallClient extends ApplicationAdapter {
	SpriteBatch batch;
	Texture img;
	
	@Override
	public void create () {
		batch = new SpriteBatch();
		img = new Texture("badlogic.jpg");
	}

	@Override
	public void render () {
		ScreenUtils.clear(1, 0, 0, 1);
		batch.begin();
		batch.draw(img, 0, 0);
		batch.end();
	}
	
	@Override
	public void dispose () {
		batch.dispose();
		img.dispose();
	}
}


```

- Create a main class for client.

```java
package com.javakaian.game;

import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;

public class ClientMain {

	public static void main(String[] args) {

		LwjglApplicationConfiguration conf = new LwjglApplicationConfiguration();

		new LwjglApplication(new KillthemallClient(), conf);

	}
}

```
That's it. Now we are done with our second tutorial. If you have an error or struggle to do steps above, you can watch my video tutorial from [this]()
link. If you find this usefull please subsrice to my youtube channel.

## Authorative Server Approach

Our game will follow authorative server and dumb clients approach. Basically it means, whenever a client wants to do an action it will send it to the server and server will check the validity of that action and respond back to client with a new state. For more in depth explanation please read [this](https://www.gabrielgambetta.com/client-server-game-architecture.html#authoritative-servers-and-dumb-clients) explanation.

<p align="center">
<img src="/images/multiplayer/server_client.png" alt="Server Client Arc" width="1000">
Client Server Architecture
</p>


As you can see from the figure above, we will have one server which will manage multiple clients. 

## State Mechanism

Our game will be composed of different States. Like:
- Play State
- Menu State
- Game Over State

Each state will have their own **Camera**, **SpriteBatch**, **SpaheRenderer**, **InputProcessor** objects. So, it will be easier for us to draw different things when game state is changed. For example, when we play the game, we will only call render and update methods of  PlayState. When the player is dead, we are going to render GameOverState which will have different texts and options.

To implement this structure, we are going to need one controller class which we will call **StateController**. StateController class will be responsible for creating different states for our needs and it will manage the game states.


```java
package com.javakaian.states;

import java.util.HashMap;
import java.util.Map;

import com.badlogic.gdx.Gdx;
import com.javakaian.states.State.StateEnum;

/**
 * * This class is responsible for controlling states in a game. It invokes
 * render and update functions of current state and binds current states input
 * processor as a processor.
 * 
 * It keeps all the states of a game inside a HashMap. If player demands a state
 * which is not already in that hashmap, it creates that state and puts it to
 * the hashmap.
 * 
 * @author oguz
 * 
 */
public class StateController {

	/** A hashmap which stores states inside. */
	private Map<Integer, State> stateMap;
	/** State object to store current state */
	private State currentState;
	/** Ip address of the server */
	private String inetAddress;

	public StateController(String ip) {

		this.inetAddress = ip;
		stateMap = new HashMap<Integer, State>();

	}

	/**
	 * Sets the current state of the game to the given state. Takes StateEnum as a
	 * parameter.
	 * 
	 * @param stateEnum
	 **/
	public void setState(StateEnum stateEnum) {

		currentState = stateMap.get(stateEnum.ordinal());
		if (currentState == null) {
			switch (stateEnum) {
			case PlayState:
				currentState = new PlayState(this);
				break;
			case GameOverState:
				currentState = new GameOverState(this);
				break;
			case MenuState:
				currentState = new MenuState(this);
				break;

			default:
				break;
			}
			stateMap.put(stateEnum.ordinal(), currentState);
		}
		Gdx.input.setInputProcessor(currentState.ip);
	}

	/**
	 * Renders the current state.
	 */
	public void render() {

		currentState.render();
	}

	/**
	 * Updates the current state.
	 */
	public void update(float deltaTime) {
		currentState.update(deltaTime);
	}

	/**
	 * Calls the dispose method of each state in the hashmap.
	 */
	public void dispose() {
		stateMap.forEach((k, v) -> {
			v.dispose();
		});
	}

	/**
	 * HashMap object which stores states of the game as key value pair.
	 */
	public Map<Integer, State> getStateMap() {
		return stateMap;
	}

	/** Returns the ip address of a server. */
	public String getInetAddress() {
		return inetAddress;
	}

}

```

Our StateController class will be like the above. It will have a HashMap which will be used to store different state objects. StateController will have an object called **CurrentState** and it will only call render and updaate methods of that current state object. When we want to change state, we will be using **setState** function. SetState function going to check the state hashmap object, if the state that we want is not on that map then it will create that state, push in to the HashMap object and will bind as an current state. Every time when we change a state, it will also bind the input processor of that state.


Our State class will be like below:

```java
package com.javakaian.states;

import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.javakaian.shooter.utils.GameConstants;
import com.javakaian.shooter.utils.GameUtils;

/**
 * 
 * This class represents the game states. Usually most of the games will have
 * states like GameOver,Option,Menu
 * 
 * Each state will have their own render and update methods.Which will be called
 * by StateController object.
 * 
 * Each state will have their own input
 * processor,shaperenderer,spritebatch,camera and also font.
 * 
 * @author oguz
 *
 */
public abstract class State {

	protected OrthographicCamera camera;
	protected InputProcessor ip;
	protected ShapeRenderer sr;
	protected SpriteBatch sb;
	protected BitmapFont bitmapFont;
	protected GlyphLayout glyphLayout;

	protected StateController sc;

	public State(StateController sc) {

		this.sc = sc;

		camera = new OrthographicCamera(GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);
		camera.setToOrtho(true);

		sr = new ShapeRenderer();
		sb = new SpriteBatch();

		sr.setProjectionMatrix(camera.combined);
		sb.setProjectionMatrix(camera.combined);

		bitmapFont = GameUtils.generateBitmapFont(70, Color.WHITE);
		glyphLayout = new GlyphLayout();

	}

	/**
	 * All the rendering stuff should be made inside this method. This will be
	 * called by StateController object.
	 */
	public abstract void render();

	/**
	 * All the update stuff should be made inside this method. This will be called
	 * by StateController object. Deltatime parameter can be used for measuring
	 * time.
	 * 
	 * @param deltaTime Time between two consecutive frames.
	 *
	 */
	public abstract void update(float deltaTime);

	/**
	 * This method will be called by StateController. Allocated resources should be
	 * released here.
	 */
	public abstract void dispose();

	/**
	 * Returns the statecontroller object.
	 */
	public StateController getSc() {
		return sc;
	}

	/** Enum for each state */
	public enum StateEnum {

		PlayState, MenuState, GameOverState, PauseState

	}

}

```

## Play State
## Menu State
## Game Over State
## Font Rendering

To render Fonts we are going to use library called **FreeType**. First we have to generate BitmapFont object with the size and the color we want. Below you can see the code snippet to generate bitmapfont. 

```java
FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal("font.ttf"));
FreeTypeFontParameter parameter = new FreeTypeFontParameter();
parameter.flip = true;
parameter.size = size;
parameter.color = color;
parameter.magFilter = TextureFilter.Linear;
parameter.minFilter = TextureFilter.Linear;
BitmapFont myFont = generator.generateFont(parameter);

```
As you can see, you need a **font.tff** file to generate fonts. There are plenty of free fonts online. You can use [this](https://www.1001fonts.com) website. Just chose the one you like and copy that **.ttf** file under your assets directory. After generating BitMapFont object with the size and color you want all you have to do that is render a string with that font. This is how we do that:

```java
font.draw(sb,"Hello", X,Y);
```
Draw method of the BitmapFont that we see above, takes 4 arguments which are
- SpriteBatch object.
- Text that we are going to draw.
- X coordinate of that text.
- Y coordinate of that text.

There is one more thing that we have to know before implementing our font rendering. When we try to center (horizontally) the text, it will be hard for us to decide the X coordinate because we don't really know the width and height of the our text. That's why we are going to use something called **GlyphLayout**. With GlyphLayout we can get the dimensions easly. To create **GlyphLayout** object all we need is **BitmapFont** object and the **String** that we are going to render. Now we can get the width and height of the text with the following simple code.


```java
GlyphLayout gl = new GlyphLayout(font, text);
int WIDTH_OF_THE_TEXT = gl.width;
int HEIGHT_OF_THE_TEXT = gl.height;
```


Since we know the width and height of the text that we are going to render and also the dimensions of the screen, we can easly align our text to the center just like this.
```java
GlyphLayout gl = new GlyphLayout(font, text);
font.draw(sb, text, GameConstants.SCREEN_WIDTH / 2 - gl.width / 2,GameConstants.SCREEN_HEIGHT * y - gl.height / 2);

```
Like we mentioned before in [State Structure](#state-mechanism) section, each state will/can have their own font which may be different size or even in the same state we may want to draw things with the different sizes and fonts. That's why we are going to write a utility class which will save us from the boiler plate code. 

```java
package com.javakaian.game.utils;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator.FreeTypeFontParameter;

public class GameUtils {

	/**
	 * Generates BitmapFont object with specified size and color parameters.
	 * 
	 * @param size  Size of the desired font
	 * @param color Color of the desired font.
	 **/
	public static BitmapFont generateBitmapFont(int size, Color color) {

		FreeTypeFontGenerator generator = new FreeTypeFontGenerator(Gdx.files.internal("font.ttf"));
		FreeTypeFontParameter parameter = new FreeTypeFontParameter();
		parameter.flip = true;
		parameter.size = size;
		parameter.color = color;
		parameter.magFilter = TextureFilter.Linear;
		parameter.minFilter = TextureFilter.Linear;
		return generator.generateFont(parameter);
	}

	/**
	 * Renders the given string to the center of the screen. (Horizontally center
	 * not vertically)
	 * 
	 * @param text String to be rendered.
	 * @param sb   SpriteBatch object
	 * @param font BitmapFont object
	 */
	public static void renderCenter(String text, SpriteBatch sb, BitmapFont font) {

		GlyphLayout gl = new GlyphLayout(font, text);
		font.draw(sb, text, GameConstants.SCREEN_WIDTH / 2 - gl.width / 2,
				GameConstants.SCREEN_HEIGHT * 0.3f - gl.height / 2);

	}

	/**
	 * Renders the given string to the center of the screen. (Horizontally center
	 * not vertically). But also allows you to specify Y location of the string.
	 * 
	 * @param text String to be rendered.
	 * @param sb   SpriteBatch object
	 * @param font BitmapFont object
	 * @param y    Y location of the text.
	 */
	public static void renderCenter(String text, SpriteBatch sb, BitmapFont font, float y) {

		GlyphLayout gl = new GlyphLayout(font, text);
		font.draw(sb, text, GameConstants.SCREEN_WIDTH / 2 - gl.width / 2,
				GameConstants.SCREEN_HEIGHT * y - gl.height / 2);

	}

}
```

After all these things, now it is so each for us to render text to the center of screen.  As it can be seen from the code below, first we create a font inside the create method and then we render that font inside the render method.
```java
public class KillthemallClient extends ApplicationAdapter {

	private SpriteBatch sb;
	private BitmapFont font;

	private OrthographicCamera camera;

	@Override
	public void create() {

		sb = new SpriteBatch();
		// Generate font with size 40 and color white.
		font = GameUtils.generateBitmapFont(40, Color.WHITE);

		camera = new OrthographicCamera();
		camera.setToOrtho(true, GameConstants.SCREEN_WIDTH, GameConstants.SCREEN_HEIGHT);

		sb.setProjectionMatrix(camera.combined);
	}

	@Override
	public void render() {
		sb.begin();
		// Render Hello world with the font that we generated.
		GameUtils.renderCenter("Hello World", sb, font);
		sb.end();
	}

	@Override
	public void dispose() {
	}
}
```
If you follow all these step you should be seing something like this.
<p align="center">
<img src="/images/multiplayer/font_rendering.png" alt="Game Play GIF" width="1000">
</p>

## Basic Connection with Server
## Creating Player
## Input Processing
## Server-side Enemy Generation
## Sending Inputs to the Server
## Rendering Other Players
## Shooting
## Collision Detection



## Conclusion

This was my first Multiplayer Game, even though it was so simple I learned a lot during the journay.
This project still lacks of features like 
- **Client-Side Prediction**, 
- **Server Reconciliation**,
- **Entity Interpolation**.
 
If you like to know more about these topics please read the awesome blog of Gabriel Gambetta [here](https://www.gabrielgambetta.com/client-server-game-architecture.html)